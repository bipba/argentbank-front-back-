import * as React from "react";
import type { Blocker, BlockerFunction, Location, ParamParseKey, Params, Path, PathMatch, PathPattern, RelativeRoutingType, Router as RemixRouter, RevalidationState, To, UIMatch } from "@remix-run/router";
import { Action as NavigationType } from "@remix-run/router";
import type { NavigateOptions, RouteContextObject, RouteMatch, RouteObject } from "./context";
/**
 * Renvoie l'URL complète (href) pour la valeur "to" donnée. Cela est utile pour créer
 * des liens personnalisés qui sont également accessibles et préservent le comportement
 * de clic droit.
 *
 * @see https://reactrouter.com/hooks/use-href
 */
export declare function useHref(to: To, { relative }?: {
    relative?: RelativeRoutingType;
}): string;

/**
 * Renvoie true si ce composant est un descendant d'un `<Router>`.
 *
 * @see https://reactrouter.com/hooks/use-in-router-context
 */
export declare function useInRouterContext(): boolean;

/**
 * Renvoie l'objet de localisation actuel, qui représente l'URL actuelle dans les navigateurs web.
 *
 * Remarque : Si vous utilisez cela, il est possible que vous fassiez vous-même
 * un peu de "routage" dans votre application, et nous aimerions connaître votre cas d'utilisation.
 * Il se peut que nous puissions fournir quelque chose de plus adapté à vos besoins.
 *
 * @see https://reactrouter.com/hooks/use-location
 */
export declare function useLocation(): Location;

/**
 * Renvoie l'action de navigation actuelle qui décrit comment le routeur est arrivé à
 * l'emplacement actuel, soit par un pop, push ou un remplacement dans la pile d'historique.
 *
 * @see https://reactrouter.com/hooks/use-navigation-type
 */
export declare function useNavigationType(): NavigationType;

/**
 * Renvoie un objet PathMatch si le modèle donné correspond à l'URL actuelle.
 * Cela est utile pour les composants qui ont besoin de connaître l'état "actif", par exemple
 * `<NavLink>`.
 *
 * @see https://reactrouter.com/hooks/use-match
 */
export declare function useMatch<ParamKey extends ParamParseKey<Path>, Path extends string>(pattern: PathPattern<Path> | Path): PathMatch<ParamKey> | null;

/**
 * Interface pour la fonction navigate() retournée par useNavigate().
 */
export interface NavigateFunction {
    (to: To, options?: NavigateOptions): void;
    (delta: number): void;
}

/**
 * Renvoie une méthode impérative pour changer l'emplacement. Utilisé par les `<Link>`, mais
 * peut également être utilisé par d'autres éléments pour changer l'emplacement.
 *
 * @see https://reactrouter.com/hooks/use-navigate
 */
export declare function useNavigate(): NavigateFunction;

/**
 * Renvoie le contexte (s'il est fourni) pour la route enfant à ce niveau de la hiérarchie des routes.
 * @see https://reactrouter.com/hooks/use-outlet-context
 */
export declare function useOutletContext<Context = unknown>(): Context;

/**
 * Renvoie l'élément de la route enfant à ce niveau de la hiérarchie des routes. Utilisé en interne par `<Outlet>`
 * pour rendre les routes enfants.
 *
 * @see https://reactrouter.com/hooks/use-outlet
 */
export declare function useOutlet(context?: unknown): React.ReactElement | null;

/**
 * Renvoie un objet de paires clé/valeur des paramètres dynamiques de l'URL actuelle
 * qui ont été correspondus par le chemin de la route.
 *
 * @see https://reactrouter.com/hooks/use-params
 */
export declare function useParams<ParamsOrKey extends string | Record<string, string | undefined> = string>(): Readonly<[
    ParamsOrKey
] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>>;

/**
 * Résout le chemin de la valeur `to` donnée par rapport à l'emplacement actuel.
 *
 * @see https://reactrouter.com/hooks/use-resolved-path
 */
export declare function useResolvedPath(to: To, { relative }?: {
    relative?: RelativeRoutingType;
}): Path;

/**
 * Renvoie l'élément de la route qui correspond à l'emplacement actuel, préparé
 * avec le contexte correct pour rendre le reste de l'arborescence des routes. Les éléments
 * de route dans l'arborescence doivent rendre un `<Outlet>` pour rendre l'élément de la route enfant.
 *
 * @see https://reactrouter.com/hooks/use-routes
 */
export declare function useRoutes(routes: RouteObject[], locationArg?: Partial<Location> | string): React.ReactElement | null;

export declare function useRoutesImpl(routes: RouteObject[], locationArg?: Partial<Location> | string, dataRouterState?: RemixRouter["state"], future?: RemixRouter["future"]): React.ReactElement | null;

type RenderErrorBoundaryProps = React.PropsWithChildren<{
    location: Location;
    revalidation: RevalidationState;
    error: any;
    component: React.ReactNode;
    routeContext: RouteContextObject;
}>;

type RenderErrorBoundaryState = {
    location: Location;
    revalidation: RevalidationState;
    error: any;
};

/**
 * Retourne l'ID de la route contextuelle la plus proche.
 */
export declare function useRouteId(): string;

/**
 * Renvoie la navigation actuelle, en se basant sur une navigation "idle" lorsqu'aucune
 * navigation n'est en cours.
 */
export declare function useNavigation(): import("@remix-run/router").Navigation;

/**
 * Renvoie une fonction de revalidation pour déclencher manuellement une revalidation, ainsi
 * que l'état actuel de toute revalidation manuelle.
 */
export declare function useRevalidator(): {
    revalidate: () => void;
    state: RevalidationState;
};

/**
 * Renvoie les correspondances de route actives, utile pour accéder aux loaderData
 * pour les routes parent/enfant ou à la propriété "handle" de la route.
 */
export declare function useMatches(): UIMatch[];

/**
 * Renvoie les données du loader pour l'ancêtre Route le plus proche.
 */
export declare function useLoaderData(): unknown;

/**
 * Renvoie les loaderData pour le routeId donné.
 */
export declare function useRouteLoaderData(routeId: string): unknown;

/**
 * Renvoie les données de l'action pour l'ancêtre Route le plus proche.
 */
export declare function useActionData(): unknown;

/**
 * Renvoie l'erreur de l'ancêtre Route le plus proche, qui pourrait être une erreur
 * de loader/action ou une erreur de rendu. Cela est destiné à être appelé à partir de votre
 * ErrorBoundary/errorElement pour afficher un message d'erreur approprié.
 */
export declare function useRouteError(): unknown;

/**
 * Renvoie les données du chemin heureux (happy-path) de la valeur `<Await />` de l'ancêtre le plus proche.
 */
export declare function useAsyncValue(): unknown;

/**
 * Renvoie l'erreur de la valeur `<Await />` de l'ancêtre le plus proche.
 */
export declare function useAsyncError(): unknown;

/**
 * Permet à l'application de bloquer les navigations au sein de l'application et de présenter à
 * l'utilisateur une boîte de dialogue de confirmation pour confirmer la navigation. Utilisé principalement
 * pour éviter de perdre des données de formulaire partiellement remplies. Cela ne gère pas les
 * rechargements durs ou les navigations cross-origin.
 */
export declare function useBlocker(shouldBlock: boolean | BlockerFunction): Blocker;
