{"ast":null,"code":"import { createAction } from \"@reduxjs/toolkit\";\nimport { loadUser } from \"./UserAction\";\n\n// URL de base pour les requêtes API utilisateur\nconst baseURL = \"http://localhost:3001/api/v1/user/\";\n\n// Création de l'action pour le succès de la récupération du token\nexport const getTokenSuccess = createAction(\"GET_TOKEN_SUCCESS\", token => ({\n  payload: token // définit le token reçu comme charge utile\n}));\n\n// Création de l'action pour une erreur lors de la récupération du token\nexport const getTokenError = createAction(\"GET_TOKEN_ERROR\", error => ({\n  payload: error // stocke l'erreur comme charge utile\n}));\n\n// Fonction asynchrone pour charger le token utilisateur\nexport const loadToken = (email, password, navigate) => async dispatch => {\n  // Envoie une action indiquant que le token est en cours de récupération\n  dispatch(getTokenSuccess({\n    isGetting: true\n  }));\n  try {\n    // Envoie une requête POST à l'API pour authentifier l'utilisateur\n    const response = await fetch(`${baseURL}login`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\" // précise le format de la requête\n      },\n      body: JSON.stringify({\n        email,\n        password\n      }) // envoie les données de connexion\n    });\n\n    // Vérifie si la requête a échoué\n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`); // lève une erreur si la réponse n'est pas correcte\n    }\n\n    // Extrait le token de la réponse JSON\n    const {\n      body: {\n        token\n      }\n    } = await response.json();\n\n    // Stocke le token dans le localStorage\n    localStorage.setItem(\"token\", token);\n\n    // Envoie une action avec le token récupéré\n    dispatch(getTokenSuccess({\n      token,\n      tokenTrue: true,\n      isGetting: false\n    }));\n\n    // Charge les infos utilisateur via le token récupéré\n    await dispatch(loadUser(token));\n\n    // Redirige l'utilisateur vers la page utilisateur après authentification\n    navigate(\"/user\");\n  } catch (error) {\n    // En cas d'erreur, envoie une action avec les détails de l'erreur\n    dispatch(getTokenError({\n      error: error.message,\n      // message d'erreur\n      isGetting: false,\n      // réinitialise l'indicateur de chargement\n      tokenTrue: false // indique que le token est invalide\n    }));\n  }\n};\n// createAction : Permet de créer des actions de manière simple, avec un type d'action et une charge utile (payload).\n\n// dispatch : Sert à envoyer des actions à Redux dans le store pour mettre à jour l'état de l'application.\n\n// fetch : Utilisé pour effectuer une requête HTTP (ici, POST) pour authentifier l'utilisateur via une API.\n\n// localStorage : Stocke localement le token pour l'utiliser dans d'autres requêtes API.\n\n// navigate : Redirige l'utilisateur après une authentification réussie.\n\n// En résumé, ce code gère la connexion de l'utilisateur, récupère un token d'authentification et \n// charge les informations utilisateur associées.\n\n// La méthode builder est spécifique à Redux Toolkit, et non à Redux \n// de base. Elle est utilisée dans la fonction createSlice de Redux \n// Toolkit pour gérer les actions asynchrones (thunks) et les reducers. \n// Plus précisément, elle apparaît dans la propriété extraReducers pour \n// gérer les actions créées en dehors du slice, comme celles provenant \n// de thunks avec createAsyncThunk.\n\n// Redux de base ne possède pas de méthode builder; c'est une \n// abstraction de Redux Toolkit qui simplifie et structure la gestion \n// de Redux.\n\n// Vous avez dit :\n// explique moi l'utlisation du store, des reducers et action. le sens logique de loeurs utilisation\n// ChatGPT a dit :\n\n// En Redux, l'architecture est basée sur trois concepts clés : le store, les reducers, et les actions. Voici comment ils s'articulent logiquement :\n\n// 1. Store\n// Le store est l'endroit où l'état global de l'application est centralisé. Il agit comme une source unique de vérité, \n// ce qui signifie que tous les composants de votre application peuvent accéder au même état centralisé. Le store est créé \n// à l’aide de createStore (dans Redux de base) ou configureStore (dans Redux Toolkit), et c’est ici que vous liez les reducers.\n\n// 2. Actions\n// Les actions sont des objets simples qui décrivent un événement ou une intention de modification de l'état. \n// Une action contient généralement un type (qui décrit l'action à effectuer) et un payload (qui contient \n//   les données nécessaires à cette action). Par exemple, une action peut ressembler à :\n\n// javascript\n// Copier le code\n// { type: 'ADD_TODO', payload: { text: 'Learn Redux' } }\n// Les actions sont dispatchées (envoyées) vers le store pour signaler qu’une modification de l’état doit avoir lieu.\n\n// 3. Reducers\n// Les reducers sont des fonctions pures qui reçoivent l'état actuel et une action, puis retournent un nouvel état. \n// Ils agissent comme des gestionnaires d’état : en fonction du type d’action reçu, ils décident comment l'état doit être modifié. \n// Un reducer peut ressembler à ceci :\n\n// javascript\n// Copier le code\n// const todoReducer = (state = [], action) => {\n//     switch (action.type) {\n//         case 'ADD_TODO':\n//             return [...state, action.payload];\n//         default:\n//             return state;\n//     }\n// };\n// Chaque modification de l'état dans Redux passe par un reducer, qui est responsable d’assurer que le nouvel état est une transformation \n// correcte de l’ancien état.\n\n// Logique de leur Utilisation Ensemble\n// Dispatch d'une Action : Lorsqu'un utilisateur effectue une action (comme cliquer sur un bouton), une action est dispatchée vers le store.\n// Reducer & Mise à jour de l'état : Le store envoie cette action au reducer approprié. Le reducer utilise cette action pour déterminer \n// comment l’état doit changer, et retourne un nouvel état.\n// Mise à jour du Store : Le store enregistre cet état mis à jour et informe tous les composants connectés, qui pourront mettre à jour \n// leur affichage en conséquence.\n// Ce cycle permet de maintenir une gestion d'état prévisible, centralisée et immuable, ce qui est particulièrement \n// utile pour des applications de grande envergure.\n\n// Si vous avez besoin d'une illustration ou d'un exemple pratique, je suis là pour aider !","map":{"version":3,"names":["createAction","loadUser","baseURL","getTokenSuccess","token","payload","getTokenError","error","loadToken","email","password","navigate","dispatch","isGetting","response","fetch","method","headers","body","JSON","stringify","ok","Error","status","json","localStorage","setItem","tokenTrue","message"],"sources":["/Users/aa/Desktop/argentbank-front-back/frontendCopie/src/store/Actions/TokenAction.js"],"sourcesContent":["import { createAction } from \"@reduxjs/toolkit\";\nimport { loadUser } from \"./UserAction\";\n\n// URL de base pour les requêtes API utilisateur\nconst baseURL = \"http://localhost:3001/api/v1/user/\";\n\n// Création de l'action pour le succès de la récupération du token\nexport const getTokenSuccess = createAction(\"GET_TOKEN_SUCCESS\", (token) => ({\n  payload: token, // définit le token reçu comme charge utile\n}));\n\n// Création de l'action pour une erreur lors de la récupération du token\nexport const getTokenError = createAction(\"GET_TOKEN_ERROR\", (error) => ({\n  payload: error, // stocke l'erreur comme charge utile\n}));\n\n// Fonction asynchrone pour charger le token utilisateur\nexport const loadToken = (email, password, navigate) => async (dispatch) => {\n  // Envoie une action indiquant que le token est en cours de récupération\n  dispatch(getTokenSuccess({ isGetting: true }));\n\n  try {\n    // Envoie une requête POST à l'API pour authentifier l'utilisateur\n    const response = await fetch(`${baseURL}login`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\", // précise le format de la requête\n      },\n      body: JSON.stringify({ email, password }), // envoie les données de connexion\n    });\n\n    // Vérifie si la requête a échoué\n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`); // lève une erreur si la réponse n'est pas correcte\n    }\n\n    // Extrait le token de la réponse JSON\n    const {\n      body: { token },\n    } = await response.json();\n\n    // Stocke le token dans le localStorage\n    localStorage.setItem(\"token\", token);\n\n    // Envoie une action avec le token récupéré\n    dispatch(getTokenSuccess({ token, tokenTrue: true, isGetting: false }));\n\n    // Charge les infos utilisateur via le token récupéré\n    await dispatch(loadUser(token));\n    \n    // Redirige l'utilisateur vers la page utilisateur après authentification\n    navigate(\"/user\");\n  } catch (error) {\n    // En cas d'erreur, envoie une action avec les détails de l'erreur\n    dispatch(\n      getTokenError({\n        error: error.message, // message d'erreur\n        isGetting: false, // réinitialise l'indicateur de chargement\n        tokenTrue: false, // indique que le token est invalide\n      })\n    );\n  }\n};\n// createAction : Permet de créer des actions de manière simple, avec un type d'action et une charge utile (payload).\n\n// dispatch : Sert à envoyer des actions à Redux dans le store pour mettre à jour l'état de l'application.\n\n// fetch : Utilisé pour effectuer une requête HTTP (ici, POST) pour authentifier l'utilisateur via une API.\n\n// localStorage : Stocke localement le token pour l'utiliser dans d'autres requêtes API.\n\n// navigate : Redirige l'utilisateur après une authentification réussie.\n\n// En résumé, ce code gère la connexion de l'utilisateur, récupère un token d'authentification et \n// charge les informations utilisateur associées.\n\n\n\n\n\n\n// La méthode builder est spécifique à Redux Toolkit, et non à Redux \n// de base. Elle est utilisée dans la fonction createSlice de Redux \n// Toolkit pour gérer les actions asynchrones (thunks) et les reducers. \n// Plus précisément, elle apparaît dans la propriété extraReducers pour \n// gérer les actions créées en dehors du slice, comme celles provenant \n// de thunks avec createAsyncThunk.\n\n// Redux de base ne possède pas de méthode builder; c'est une \n// abstraction de Redux Toolkit qui simplifie et structure la gestion \n// de Redux.\n\n\n\n\n\n\n// Vous avez dit :\n// explique moi l'utlisation du store, des reducers et action. le sens logique de loeurs utilisation\n// ChatGPT a dit :\n\n// En Redux, l'architecture est basée sur trois concepts clés : le store, les reducers, et les actions. Voici comment ils s'articulent logiquement :\n\n// 1. Store\n// Le store est l'endroit où l'état global de l'application est centralisé. Il agit comme une source unique de vérité, \n// ce qui signifie que tous les composants de votre application peuvent accéder au même état centralisé. Le store est créé \n// à l’aide de createStore (dans Redux de base) ou configureStore (dans Redux Toolkit), et c’est ici que vous liez les reducers.\n\n// 2. Actions\n// Les actions sont des objets simples qui décrivent un événement ou une intention de modification de l'état. \n// Une action contient généralement un type (qui décrit l'action à effectuer) et un payload (qui contient \n//   les données nécessaires à cette action). Par exemple, une action peut ressembler à :\n\n// javascript\n// Copier le code\n// { type: 'ADD_TODO', payload: { text: 'Learn Redux' } }\n// Les actions sont dispatchées (envoyées) vers le store pour signaler qu’une modification de l’état doit avoir lieu.\n\n// 3. Reducers\n// Les reducers sont des fonctions pures qui reçoivent l'état actuel et une action, puis retournent un nouvel état. \n// Ils agissent comme des gestionnaires d’état : en fonction du type d’action reçu, ils décident comment l'état doit être modifié. \n// Un reducer peut ressembler à ceci :\n\n// javascript\n// Copier le code\n// const todoReducer = (state = [], action) => {\n//     switch (action.type) {\n//         case 'ADD_TODO':\n//             return [...state, action.payload];\n//         default:\n//             return state;\n//     }\n// };\n// Chaque modification de l'état dans Redux passe par un reducer, qui est responsable d’assurer que le nouvel état est une transformation \n// correcte de l’ancien état.\n\n// Logique de leur Utilisation Ensemble\n// Dispatch d'une Action : Lorsqu'un utilisateur effectue une action (comme cliquer sur un bouton), une action est dispatchée vers le store.\n// Reducer & Mise à jour de l'état : Le store envoie cette action au reducer approprié. Le reducer utilise cette action pour déterminer \n// comment l’état doit changer, et retourne un nouvel état.\n// Mise à jour du Store : Le store enregistre cet état mis à jour et informe tous les composants connectés, qui pourront mettre à jour \n// leur affichage en conséquence.\n// Ce cycle permet de maintenir une gestion d'état prévisible, centralisée et immuable, ce qui est particulièrement \n// utile pour des applications de grande envergure.\n\n// Si vous avez besoin d'une illustration ou d'un exemple pratique, je suis là pour aider !\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,kBAAkB;AAC/C,SAASC,QAAQ,QAAQ,cAAc;;AAEvC;AACA,MAAMC,OAAO,GAAG,oCAAoC;;AAEpD;AACA,OAAO,MAAMC,eAAe,GAAGH,YAAY,CAAC,mBAAmB,EAAGI,KAAK,KAAM;EAC3EC,OAAO,EAAED,KAAK,CAAE;AAClB,CAAC,CAAC,CAAC;;AAEH;AACA,OAAO,MAAME,aAAa,GAAGN,YAAY,CAAC,iBAAiB,EAAGO,KAAK,KAAM;EACvEF,OAAO,EAAEE,KAAK,CAAE;AAClB,CAAC,CAAC,CAAC;;AAEH;AACA,OAAO,MAAMC,SAAS,GAAGA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,QAAQ,KAAK,MAAOC,QAAQ,IAAK;EAC1E;EACAA,QAAQ,CAACT,eAAe,CAAC;IAAEU,SAAS,EAAE;EAAK,CAAC,CAAC,CAAC;EAE9C,IAAI;IACF;IACA,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAE,GAAEb,OAAQ,OAAM,EAAE;MAC9Cc,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACP,cAAc,EAAE,kBAAkB,CAAE;MACtC,CAAC;MACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;QAAEX,KAAK;QAAEC;MAAS,CAAC,CAAC,CAAE;IAC7C,CAAC,CAAC;;IAEF;IACA,IAAI,CAACI,QAAQ,CAACO,EAAE,EAAE;MAChB,MAAM,IAAIC,KAAK,CAAE,uBAAsBR,QAAQ,CAACS,MAAO,EAAC,CAAC,CAAC,CAAC;IAC7D;;IAEA;IACA,MAAM;MACJL,IAAI,EAAE;QAAEd;MAAM;IAChB,CAAC,GAAG,MAAMU,QAAQ,CAACU,IAAI,CAAC,CAAC;;IAEzB;IACAC,YAAY,CAACC,OAAO,CAAC,OAAO,EAAEtB,KAAK,CAAC;;IAEpC;IACAQ,QAAQ,CAACT,eAAe,CAAC;MAAEC,KAAK;MAAEuB,SAAS,EAAE,IAAI;MAAEd,SAAS,EAAE;IAAM,CAAC,CAAC,CAAC;;IAEvE;IACA,MAAMD,QAAQ,CAACX,QAAQ,CAACG,KAAK,CAAC,CAAC;;IAE/B;IACAO,QAAQ,CAAC,OAAO,CAAC;EACnB,CAAC,CAAC,OAAOJ,KAAK,EAAE;IACd;IACAK,QAAQ,CACNN,aAAa,CAAC;MACZC,KAAK,EAAEA,KAAK,CAACqB,OAAO;MAAE;MACtBf,SAAS,EAAE,KAAK;MAAE;MAClBc,SAAS,EAAE,KAAK,CAAE;IACpB,CAAC,CACH,CAAC;EACH;AACF,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAOA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAOA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}